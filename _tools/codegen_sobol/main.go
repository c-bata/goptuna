package main

/*
The original data of direction numbers is available at:
https://web.maths.unsw.edu.au/~fkuo/sobol/ (BSD License)

Please download it and run following command:
$ go run _tools/codegen_sobol/main.go ./tmp/new-joe-kuo-6.21201 ./sobol/direction_numbers.go
*/

import (
	"bufio"
	"flag"
	"fmt"
	"log"
	"os"
	"strconv"
	"strings"
)

type DirectionNumber struct {
	D uint32   // dimension
	S uint32   // the degree of the primitive polynomial
	A uint32   // the number representing the coefficients
	M []uint32 // the list of initial direction numbers
}

// ParseJoeKuoDirectionNumbers parse the file which contains the direction numbers
// distributed at https://web.maths.unsw.edu.au/~fkuo/sobol/ (BSD License).
func ParseJoeKuoDirectionNumbers(filepath string) ([]DirectionNumber, error) {
	f, err := os.Open(filepath)
	defer f.Close()
	if err != nil {
		return nil, err
	}

	directionNumbers := make([]DirectionNumber, 0, 21201)
	scanner := bufio.NewScanner(f)
	scanner.Scan() // skip 1st line

	for scanner.Scan() {
		line := scanner.Text()
		rows := strings.Fields(line)

		d, err := strconv.ParseUint(rows[0], 10, 32)
		if err != nil {
			return nil, err
		}
		s, err := strconv.ParseUint(rows[1], 10, 32)
		if err != nil {
			return nil, err
		}
		a, err := strconv.ParseUint(rows[2], 10, 32)
		if err != nil {
			return nil, err
		}
		mi := make([]uint32, len(rows)-3)
		for i, miItemStr := range rows[3:] {
			x, err := strconv.ParseUint(miItemStr, 10, 32)
			if err != nil {
				return nil, err
			}
			mi[i] = uint32(x)
		}

		directionNumbers = append(directionNumbers, DirectionNumber{
			D: uint32(d),
			S: uint32(s),
			A: uint32(a),
			M: mi,
		})
	}
	if err := scanner.Err(); err != nil {
		return nil, err
	}

	return directionNumbers, nil
}

func main() {
	flag.Parse()
	inputFilePath := flag.Arg(0)
	outputFilePath := flag.Arg(1)
	if inputFilePath == "" || outputFilePath == "" {
		log.Fatalln("Please specify an input and output file path. (ex: ./new-joe-kuo-6.21201)")
	}

	directionNumbers, err := ParseJoeKuoDirectionNumbers(inputFilePath)
	if err != nil {
		log.Fatalln(err)
	}

	fout, err := os.Create(outputFilePath)
	defer fout.Close()
	if err != nil {
		log.Fatalln(err)
	}

	cmd := "go run _tools/sobol_direction_numbers/main.go " + strings.Join(os.Args[1:], " ")
	fmt.Fprintf(fout, "// Code generated by \"%s\"; DO NOT EDIT.\n", cmd)
	fmt.Fprintf(fout, "\n")
	fmt.Fprintf(fout, "package sobol\n")
	fmt.Fprintf(fout, "\n")
	fmt.Fprintf(fout, "// The original data of direction numbers is distributed at https://web.maths.unsw.edu.au/~fkuo/sobol/ (BSD License).\n")
	fmt.Fprintf(fout, "\n")
	fmt.Fprintf(fout, "const maxDim = 21201 - 1002  // Due to skip 1000 lines\n")
	fmt.Fprintf(fout, "const maxDeg = 18\n")
	fmt.Fprintf(fout, "const maxBit = 30\n")
	fmt.Fprintf(fout, "\n")
	fmt.Fprintf(fout, "type DirectionNumber struct {\n")
	fmt.Fprintf(fout, "\tD uint32\n")
	fmt.Fprintf(fout, "\tS uint32\n")
	fmt.Fprintf(fout, "\tA uint32\n")
	fmt.Fprintf(fout, "\tM []uint32\n")
	fmt.Fprintf(fout, "}\n")
	fmt.Fprintf(fout, "\n")

	fmt.Fprintf(fout, "var directionNumbers = []DirectionNumber{")
	for _, dn := range directionNumbers {
		mStr := ""
		for _, m := range dn.M {
			if mStr == "" {
				mStr += fmt.Sprintf("%d", m)
			} else {
				mStr += fmt.Sprintf(", %d", m)
			}
		}
		fmt.Fprintf(fout, "{D: %d, S: %d, A: %d, M: []uint32{%s}},", dn.D, dn.S, dn.A, mStr)
	}

	fmt.Fprintf(fout, "}\n")
}
